# CPU 스케줄링

CPU 스케줄링은 운영 체제가 시스템의 CPU 자원을 효율적으로 사용하기 위해 실행할 프로세스(또는 스레드)를 결정하는 메커니즘입니다. CPU 스케줄러는 여러 프로세스가 동시에 실행되도록 스케줄링하여 시스템 성능과 응답성을 최적화합니다.

## CPU 스케줄링의 목표

- CPU 사용률 극대화: CPU가 가능한 한 쉬지 않고 작업을 처리하도록 합니다.
- 스루풋 최대화: 단위 시간당 최대한 많은 프로세스를 완료합니다.
- 응답 시간 최소화: 사용자 요청에 대한 응답 시간을 줄입니다.
- 공정성 보장: 모든 프로세스가 공정하게 CPU 시간을 할당받도록 합니다.

## CPU 스케줄링 알고리즘

1. FCFS (First-Come, First-Served)
   특징: 프로세스가 도착한 순서대로 CPU를 할당합니다.
   장점: 구현이 간단합니다.
   단점: 비효율적인 경우가 많습니다. 예를 들어, CPU 시간이 긴 프로세스가 먼저 도착하면, 뒤에 도착한 짧은 프로세스들이 오래 기다리게 되는 Convoy Effect가 발생할 수 있습니다.
2. SJF (Shortest Job First)
   특징: 실행 시간이 가장 짧은 프로세스에 먼저 CPU를 할당합니다.
   장점: 평균 대기 시간을 최소화할 수 있습니다.
   단점: 프로세스의 실행 시간을 미리 알기 어렵고, 긴 프로세스가 계속 대기하게 되는 Starvation 문제가 발생할 수 있습니다.
3. Priority Scheduling
   특징: 우선순위가 높은 프로세스에 먼저 CPU를 할당합니다.
   장점: 중요하거나 긴급한 작업을 먼저 처리할 수 있습니다.
   단점: 낮은 우선순위의 프로세스가 계속 대기하게 되는 Starvation 문제가 발생할 수 있습니다. 이를 방지하기 위해 Aging 기법을 사용하여 시간이 지남에 따라 우선순위를 높이는 방법을 사용합니다.
4. Round Robin (RR)
   특징: 각 프로세스는 동일한 시간 할당량(퀀텀)을 가지며, 순환하면서 CPU를 할당받습니다.
   장점: 공정성을 보장하며, 응답 시간이 예측 가능합니다.
   단점: 시간 할당량이 너무 작으면 문맥 교환 오버헤드가 커지고, 너무 크면 FCFS와 비슷해집니다.
5. Multilevel Queue Scheduling
   특징: 프로세스를 우선순위에 따라 여러 개의 큐로 분류하여 각 큐에 다른 스케줄링 알고리즘을 적용합니다.
   장점: 다양한 종류의 프로세스를 효과적으로 관리할 수 있습니다.
   단점: 큐 간의 상호작용과 스케줄링 정책이 복잡해질 수 있습니다.
6. Multilevel Feedback Queue Scheduling
   특징: 프로세스가 일정 시간 동안 실행된 후 우선순위가 낮은 큐로 이동하며, 상위 큐에서 실행 기회를 얻지 못한 프로세스는 하위 큐로 이동합니다.
   장점: 다양한 프로세스 특성을 동적으로 반영할 수 있습니다.
   단점: 구현이 복잡합니다.

## 스케줄링 기준

- CPU 사용률 (CPU Utilization): CPU가 유휴 상태가 아닌 시간을 최대화합니다.
- 스루풋 (Throughput): 단위 시간당 처리되는 프로세스의 수를 최대화합니다.
- 대기 시간 (Waiting Time): 프로세스가 준비 큐에서 대기하는 시간을 최소화합니다.
- 응답 시간 (Response Time): 프로세스가 처음으로 CPU를 할당받는 시간을 최소화합니다.
- 반환 시간 (Turnaround Time): 프로세스가 제출된 시점부터 완료되는 시점까지의 시간을 최소화합니다.

## 문맥 교환 (Context Switching)

문맥 교환은 CPU가 한 프로세스에서 다른 프로세스로 전환될 때 발생합니다. 문맥 교환 과정에서 현재 프로세스의 상태를 PCB에 저장하고, 다음 프로세스의 상태를 로드합니다. 문맥 교환은 오버헤드가 발생하므로, 스케줄링 알고리즘은 문맥 교환을 최소화하면서도 효율적인 CPU 사용을 목표로 합니다.
